---
layout: slides
permalink: /lecture/1/slides
category: slides
---

class: center, middle

# Welcome to Python 101!


---
class: inverse, center, middle

# A caffeinated tour

---


# Agenda

1. Variables
2. Statements and expressions
3. Built-in types
4. Control flow (conditionals, loops)
5. Functions
6. Strings
7. File I/O

---

# Literals

- **numbers**: what you might expect
```python
	123, 45.6, 7.8j
```

- **strings**: single, double or triple.red.bold[*] quotes
```python
	'hello', "hello", "Say 'hello'!"
```

.footnote[.red.bold[*] Allows literal line breaks; often used as "docstrings" (later)]

---

# Variables

- variable names (identifiers) must start with a letter or underscore _

- **cannot** be one of Python's .red[reserved keywords]:

.center[
```
in is and or not 
if elif else
for while continue break
try except finally raise
class def pass return yield assert
from import global del lambda with
```
]

- variable assignment with the `=` operator
```python
>>> x = 5
>>> y = 'foo'
>>> z = None
```

---

# Types

.left-column[
- Numeric
```python
int, float, complex
```

- Boolean (logical)
```python
bool
```

- String (text)
```python
str
```

- Binary sequences
```python
bytes
```
]


.right-column[

- Collection types
	- `list`
	- `tuple`
	- `set`
	- `frozenset`
	- `dict`

- Lots of other specialized built-in types (e.g., `datetime`)
]

---
class: middle

## Variables in Python are _dynamically typed_

C/C++
```C
unsigned int myInt = 5;
myInt = "five";   // compiler error!
```

Python
```python
my_int = 5
my_int = "five"  # Not a problem!
```

---
# Statements and expressions

```python
from math import sqrt             # Import statement

print("hello world")              # Function call expression

x = 5                             # Assignment statement

x += 1                            # Augmented assignment

x = 3.14 * x * (1 - x)**sqrt(x)   # Assigment with expression

x = 100 if y > 0 else -100        # Conditional expression

```

---

# Comments

```python

# I am a comment
spam = 'eggs'  # So am I!

```
---

# Operators

- Arithmetic: `+`, `-`, `*`, `/`, `//`, `**`, `%`
- Comparison: `==`, `!=`, `>`, `<`, `>=`, `<=`
- Assignment: `=`, `+=`, `-=`, `*=`, `/=`
- Logical: `and`, `or`, `not`
- Membership: `in`, `not in`
- Identity*: `is`, `is not`
<!-- - Bitwise: `&`, `|`, `^`, `<<`, `>>`
 -->


Operator [precedence rules](https://docs.python.org/3/reference/expressions.html#operator-precedence)

\* The `==` operator tests whether two variables have the same _value_, whereas the `is` operator tests whether two variables _refer to the same object_.

---

# Strings

Strings are **immutable** sequences of Unicode characters (i.e., text).

- They use [zero-based positional indexing](https://en.wikipedia.org/wiki/Zero-based_numbering)
- They can be queried by positional _index_ and _sliced_

<pre>
<code class="python">
>>> text = "Clubes de Ciencia"

>>> print(text[0], text[1], text[2], text[3], text[-3], text[-2], text[-1])
</code><code>C l u b c i a</code><code class="python">
>>> text[-7:]    # start, stop
</code><code>'Ciencia'</code><code class="python">
>>> text[0:5]    # start, stop
</code><code>'Clube'</code><code class="python">
>>> text[::2]    # start, stop, step
</code><code>'Cue eCeca'</code><code class="python">
>>> text[::-1]   # start, stop, step
</code><code>'aicneiC ed sebulC'</code>
</pre>

---

# Strings

Strings are immutable. That means that operations cannot modify a string in-place. String manipulation operations always produce a new string object.

<pre>
<code class="python">
>>> text[0] = 'K'
</code><code style="color: red;">TypeError: 'str' object does not support item assignment</code><code class="python">
>>> text_lowercase = text.lower()
>>> text_lowercase
</code><code>'clubes de ciencia'</code>
</pre>

Strings support several operators.

<pre>
<code class="python">
>>> 'hello' + ' ' + 'world'
</code><code>'hello world'</code><code class="python">
>>> 'hello'*3
</code><code>'hellohellohello'</code><code class="python">
>>> 'g' in 'hello'
</code><code>False</code>
</pre>


---

# Tuples and Lists

Tuples and lists are examples of _heterogeneous sequence_ data types.

- Both can contain objects of different types
- Both use zero-based indexing
- Both can be sliced

<pre><code class="python">
>>> x = (0,)
>>> y = (1, "Two", 3)
>>> y[1]
</code><code>'Two'</code><code class="python">
>>> x = [0, 1, 2]
>>> y = [3, 4, 5]
>>> x + y
</code><code>[0, 1, 2, 3, 4, 5]</code>
<code class="python">
>>> x[1:-1]
</code><code>[1, 2, 3, 4]</code>
</pre>
---

# Tuples and Lists

How do they differ?

- Tuples are **immutable** sequences (like strings!).

```python
>>> y = (1,2,3)
>>> y[1] = 'Two'  # TypeError!
```

- Lists are **mutable**
- O(1) amortized insertion at the end

<pre><code class="python">
>>> x = [1,2]
>>> x[1] = 'Two'
>>> x.append(3)
>>> x.extend([4,'Five',6])
>>> x
</code><code>[1, 'Two', 3, 4, 'Five', 6]</code>
</pre>

---

# Sets

A set in an *unordered* collection of *unique* elements.

<pre><code class="python">
>>> x = set([1,3,2,2,2,3])
>>> print(x)
</code><code>{1, 2, 3}</code>
<code class="python">
>>> 4 in x
</code><code>False</code>
</pre>

`set` objects are mutable.
<pre>
<code class="python">
>>> x.add(4)
>>> 4 in x
</code><code>True</code>
</pre>


The immutable version is called `frozenset`.

---

# Dictionaries

- _a.k.a._ "associative mapping", _a.k.a._ "hash table", ...

Dictionaries map [hashable](https://docs.python.org/2/glossary.html#term-hashable) objects called **keys** to arbitrary objects called **values**.

- The items of a dictionary are unordered.
- `dict`s are mutable objects.

<pre>
<code class="python">
>>> fruits = {'apples': 3, 'oranges': 1}
>>> fruits['bananas'] = 2
>>> list(fruits.keys())
</code><code>['apples', 'bananas', 'oranges']</code><code class="python">>>> list(fruits.values())
</code><code>[3, 2, 1]</code>
</pre>

---

# Conditionals

Note the importance of indentation!

```python
if x < 2:
	print("x is small")
elif x < 10:
	print("x is medium")
elif x < 20:
	print("x is big")
elif x < 40:
	print("x is large")
elif x < 100:
	print("x is huge")
else:
	print("x is ginormous!")
```
---
# Truthiness

- **truthy**: `True`, any nonzero number, non-empty strings, non-empty collections
- **falsy**: `False`, `None`, `0`, `''`, empty collections (`__len__()` returns 0)

.left-column[

```python
while True:
	... do something ...
	if len(buffer) == 0:
		print("buffer is empty")
		break

while buffer:  # exits when buffer is empty
	... do something ...

```
]

.right-column[<img src="{{ '/assets/img/truthiness.jpg' | prepend: site.baseurl }}">]



---
class: inverse

# Significant whitespace

```python
>>> from __future__ import braces
```

---
class: inverse

# Significant whitespace

```python
>>> from __future__ import braces
```

<code style="color: red;">SyntaxError: not a chance</code>

---
class: middle

```
Also, 
	don't mix 
 spaces and 
 		tabs!
```

---

# Functions

### Definition

```python
def print_lyrics():
	print("I'm a lumberjack, and I'm okay.")
	print("I sleep all night and I work all day.")
```

### Invocation (calling)

<pre><code class="python">
>>> print_lyrics()
</code><code>I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.</code>
</pre>

---

# Functions

### Arguments

Function definitions can include parameters.
- The values passed into a function are called _arguments_.

```python
def greet(name, lang):
	if lang == 'es':
		print("Hola, " + name + "!")
	elif lang == 'en':
		print("Hello, " + name + "!")
	else:
		raise ValueError("Language not available")
```

---

# Functions

### Arguments

Functions can be called (invoked) with two types of argument:
- positional arguments
- keyword arguments

Correct!
```python
greet("Mariana", "es") 
greet("Mariana", lang="es")
greet(name="Mariana", lang="es")
greet(lang="es", name="Mariana")
```

Wrong!
```python
greet("Mariana")  # TypeError! only one argument
greet(name="Mariana", "es")  # SyntaxError! non-keyword arg after keyword arg
```
---

# Functions

### Arguments

Arguments can be given default values


```python
def greet(name, lang="es"):
	if lang == 'es':
		print("Hola, " + name + "!")
	elif lang == 'en':
		print("Hello, " + name + "!")
	else:
		raise ValueError("Language not available")
```

Now this works:
<pre><code class="python">
>>>greet("Mariana")
</code><code>Hola, Mariana!</code>
</pre>


---

# Functions

### Return values

Functions always return a value
- Default return value is `None`

Let's make our function return the greeting as a string.

```python
def greet(name, lang="es"):
	if lang == 'es':
		greeting = "Hola, " + name + "!"
	elif lang == 'en':
		greeting = "Hello, " + name + "!"
	else:
		raise ValueError("Language not available")
	return greeting
```

<pre><code class="python">
>>>print(greet("Mariana"))
</code><code>Hola, Mariana!</code>
</pre>

---
# Functions

### Docstrings

Adding documentation to your functions. (try typing `help(greet)`)

```python
def greet(name, lang="es"):
	"""
	Returns a greeting in one of two languages.

	Inputs
	------
	name: your name
	lang: 'en' for English or 'sp' for Spanish

	Returns
	-------
	A greeting string

	"""
	if lang == 'es':
		greeting = "Hola, " + name + "!"
	elif lang == 'en':
		greeting = "Hello, " + name + "!"
	else:
		raise ValueError("Language not available")
	return greeting
```
---

# Exceptions

Errors detecting during execution can be caught and handled!

- `Exception` (base type)
- `ValueError`
- `TypeError`
- `KeyError`
- `IndexError`
- `AttributeError`
- `ZeroDivisionError`
- `OSError`
- [...](https://docs.python.org/3.5/library/exceptions.html#bltin-exceptions)


---
# Try/Except

Useful when you're about to do something dangerous...

```python
input_string = input("Please enter a number: ")   # Never trust user input!

try:
	value = int(input_string)
except ValueError:  # User provided something that couldn't be converted to int.
	value = -1

if value == -1:
	print("Not a number")
else:
	print("Thank you!")
```
---


# Loops


```
while <conditional-expression>:
	...
```

```
for <element> in <iterable>:
	...

```

---

# Loops

```python
x = 0
while x < 3:
	line = input("> ")
	print(line)
	x += 1

print("Done!")
```

---

# Loops

```python
while True:
	line = input("> ")
	if line == "done":
		break
	print(line)

print("Done!")
```
---

# Loops

```python
while True:
	line = input("> ")
	if line == '#':
		continue
	if line == "done":
		break
	print(line)

print("Done!")
```
---

# Loops

You can iterate over anything that behaves like a sequence!

```python
for i in [5, 4, 3, 2, 1]:
	print(i)
print("Blastoff!")

for letter in 'banana':
	print(letter)
```

Careful! For sets and dicts, the iteration order is arbitrary.

```python
fruits = {'oranges', 'apples', 'bananas'}
for fruit in fruits:   
	print(fruit)

fruit_counts = {'oranges': 5, 'bananas':2, 'apples': 1}
for fruit, amount in fruit_counts.items():
	print(fruit, amount)
```

---


# Built-in functions

Examples:

- `max`, `min`
- `round`, `abs`
- `len`
- `range`
- `sorted`
- `reversed`
- `enumerate`
- `zip`
- `input`
- `print`
- `open`
- `help`
- `dir`
- [...](https://docs.python.org/3.5/library/functions.html)
<!-- - `map`, `reduce`, `filter` -->
---

# More about strings

### Some useful methods

- `upper`, `lower`
- `strip`, `lstrip`, `rstrip`
- `split`, `join`
- `find`, `replace`
- `count`

for inspection
- `isupper`, `islower`
- `isalnum`, `isnumeric`, `isdigit`, `isdecimal`

---
# More about strings

### Escaping special characters

| escape sequence | meaning|
|-----------------|--------|
| `\'`            | single quote|
| `\"`            | double quote|
| `\n`            | line feed |
| `\t`            | tab |
| `\\`            | backslash|  

---
# More about strings

.float-right[<img src="http://www.businessweek.com/graphics/success-links/images/success_shaq18__180x180.jpg">]


### Formatting (string interpolation)

<pre><code class="python">
>>> name = "Shaq"
>>> height_in_cm = 216
</code>
</pre>

- The old way: [`%` operator](https://docs.python.org/3.4/library/stdtypes.html#printf-style-string-formatting)
<pre><code class="python">
>>> "Hi, my name is %s and I am %.2f meters tall" % (name, height_in_cm / 100)
</code>
</pre>

- The new way [`str.format`](https://docs.python.org/3.4/library/string.html#formatstrings)
<pre><code class="python">
>>> "Hi, my name is {} and I am {} meters tall".format(name, height_in_cm / 100)
</code>
</pre>

`'Hi, my name is Shaq and I am 2.16 meters tall'`

---

# Text files

The `open` built-in function returns a "handle" to a file.

```python
handle = open(filename, mode)

```

Mode can be: 

| mode |  meaning |
|------|----------|
|`r`   | open to read text |
|`x`   | open to write text, fail if file exists |
|`w`   | open to write text, overwrites if file exists |
|`a`   | open to write text, appending if file exists |
|`+`   | open for reading and writing |

Default is `'r'`.

---

# Text files

File handles are iterable sequences!

```
cheeseshop.txt
--------------
Brie
Roquefort
Pol le Veq
Port Salut
Savoy Aire
Saint Paulin
Carrier de lest
Bres Bleu
Bruson
Camenbert
```

```python
cheese_file = open('cheeseshop.txt', 'r')

for line in cheese_file:
	cheese = line.rstrip()  # remove trailing whitespace and newline character
	print(cheese)

```

---

# In Python, everything is an _object_

Objects have a well-defined type and can be assigned to variables. 

- We've seen examples of built-in objects with types `str`, `float`, `dict`, etc. But functions, file handles, and even `None` are objects too.
	- e.g., we can pass the builtin function `int` as an argument to another builtin function, `map`
```python
>>> map(int, [1.15, 2.08, 3.14, 4.89])
[1, 2, 3, 4]
```


- Many objects have accessible properties called _attributes_. 
	- attributes are accessed using dot `.` notation
- Many objects also have callable attributes _methods_.
	- these are special functions that are bound to objects
- We can create our own custom objects by "deriving" or "subclassing" them from builtins.
	- this is called "object-oriented programming" (more later)

{% comment %}
---

# Batteries included: The Standard Library

Some useful modules:

- `os`
- `sys` (python path, modules, command line args)
- `collections`
- `heapq`
- `math`
- `re`
- `json`
- `time`
- `datetime`
- `unittest`




---

# Functions are objects too!


### Anonymous functions

Functions not bound to a name. 
	- Can only contain a single expression.
	- Doesn't need to be assigned to a variable.
	- Handy for "functional programming" concepts.

---
{% endcomment %}
